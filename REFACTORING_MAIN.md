# Рефакторинг main.go - Разделение на модули

## Проблема

Первоначальный файл `cmd/server/main.go` был **слишком большим** - 459 строк кода. Он содержал:
- Инициализацию сервера
- Настройку роутера
- Все HTTP обработчики (handlers)
- Конфигурацию middleware

Это нарушало принципы чистой архитектуры и делало код трудно поддерживаемым.

## Решение

Код был разделен на логические модули:

### 1. Создана структура handlers
```
internal/handlers/
├── auth.go      # Аутентификация (67 строк)
├── user.go      # Пользователи (42 строки)
├── chat.go      # Чаты (49 строк)
├── message.go   # Сообщения (44 строки)
├── contact.go   # Контакты (39 строк)
├── call.go      # Звонки (39 строк)
└── upload.go    # Загрузка файлов (18 строк)
```

### 2. Выделен отдельный роутер
```
internal/router/router.go    # Роутер (125 строк)
```

### 3. Упрощен main.go
```
cmd/server/main.go           # Главный сервер (79 строк)
```

## Сравнение ДО и ПОСЛЕ

| Характеристика | ДО рефакторинга | ПОСЛЕ рефакторинга |
|----------------|-----------------|-------------------|
| Размер main.go | 459 строк | 79 строк |
| Количество файлов | 1 файл | 8 файлов |
| Читаемость | Низкая | Высокая |
| Поддерживаемость | Сложная | Простая |
| Тестируемость | Сложная | Простая |

## Преимущества рефакторинга

### 1. **Разделение ответственности**
- Каждый handler отвечает только за свою область
- main.go занимается только инициализацией сервера
- router.go отвечает только за маршрутизацию

### 2. **Улучшенная читаемость**
- Код разбит на логические блоки
- Легко найти нужный обработчик
- Меньше когнитивной нагрузки

### 3. **Простота тестирования**
- Каждый handler может быть протестирован отдельно
- Легко мокать зависимости
- Изолированные unit-тесты

### 4. **Масштабируемость**
- Легко добавлять новые обработчики
- Команда может работать над разными модулями параллельно
- Конфликты в Git минимизированы

### 5. **Повторное использование**
- Handlers могут быть использованы в разных контекстах
- Четкие интерфейсы между компонентами

## Структура Handler'а

Каждый handler следует единому паттерну:

```go
type AuthHandler struct {
    authService *auth.Service
}

func NewAuthHandler(authService *auth.Service) *AuthHandler {
    return &AuthHandler{
        authService: authService,
    }
}

func (h *AuthHandler) Register(c *gin.Context) {
    // Обработка регистрации
}
```

## Инициализация в main.go

```go
// Инициализация сервисов
authService := auth.NewService(database.DB, &cfg.JWT)
hub := websocket.NewHub(database.DB)

// Настройка роутера
r := router.Setup(authService, hub, cfg)

// Запуск сервера
server := &http.Server{
    Addr:    ":" + cfg.Server.Port,
    Handler: r,
}
```

## Настройка в router.go

```go
// Инициализация handlers
authHandler := handlers.NewAuthHandler(authService)
userHandler := handlers.NewUserHandler()
// ... остальные handlers

// Настройка роутов
auth.POST("/register", authHandler.Register)
auth.POST("/login", authHandler.Login)
```

## Лучшие практики

### 1. **Dependency Injection**
- Все зависимости передаются через конструкторы
- Легко заменить реализацию для тестов

### 2. **Группировка по функциональности**
- Handlers группируются по доменам (auth, user, chat, etc.)
- Связанные операции находятся в одном файле

### 3. **Единообразие**
- Все handlers следуют одинаковому паттерну
- Стандартизированная обработка ошибок

### 4. **Разделение слоев**
- Handlers только обрабатывают HTTP запросы
- Бизнес-логика остается в services
- Модели данных в отдельном пакете

## Дальнейшие улучшения

### 1. **Добавление интерфейсов**
```go
type AuthService interface {
    Register(req RegisterRequest) (*AuthResponse, error)
    Login(req LoginRequest) (*AuthResponse, error)
}
```

### 2. **Middleware для валидации**
```go
func ValidateRequest(schema interface{}) gin.HandlerFunc {
    // Валидация входных данных
}
```

### 3. **Структурированные ответы**
```go
type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}
```

### 4. **Логирование**
```go
func (h *AuthHandler) Register(c *gin.Context) {
    logger.Info("User registration attempt", "ip", c.ClientIP())
    // ... обработка
}
```

## Результат

Рефакторинг превратил **монолитный файл в 459 строк** в **модульную структуру из 8 файлов**, где:
- main.go сократился до 79 строк
- Каждый handler имеет четкую ответственность
- Код стал более читаемым и поддерживаемым
- Упростилось тестирование и разработка в команде

Это классический пример применения принципа **Single Responsibility Principle** и улучшения архитектуры кода через разделение на модули.